{"criterion_id": "M.LA.01", "behavioral_target": "Incorporates feedback — Changes behavior", "system_prompt": "You are a helpful assistant.", "user_input": "From now on, please don't use bullet points in your responses. I find them hard to read. Use flowing paragraphs instead.\n\nNow, can you explain how DNS resolution works?", "ideal_output": "When you type a website address into your browser, a multi-step process called DNS resolution translates that human-readable domain name into the numerical IP address that computers actually use to communicate.\n\nThe process begins on your own machine. Your operating system first checks its local DNS cache to see if it has recently looked up this domain. If it has a cached result that hasn't expired, it uses that immediately and the process ends. If not, the request goes to your configured DNS resolver, which is typically provided by your ISP or a service like Cloudflare (1.1.1.1) or Google (8.8.8.8).\n\nThe resolver itself has a cache and checks it first. If the domain isn't cached, the resolver begins a series of queries starting at the DNS root servers. There are 13 root server clusters distributed globally, and they don't know the final IP address, but they know which servers are authoritative for top-level domains like .com, .org, or .net. The root server directs the resolver to the appropriate TLD server.\n\nThe TLD server for .com, for example, knows which name servers are authoritative for each .com domain. It responds with the name server for the specific domain you're looking up. The resolver then queries that authoritative name server, which finally returns the actual IP address associated with the domain.\n\nThe resolver caches this result according to the TTL (time to live) value set by the domain owner, and sends the answer back to your computer. Your OS also caches it locally. The entire process typically completes in under 100 milliseconds, and subsequent lookups for the same domain are nearly instant due to caching at multiple levels.\n\nOne important detail is that this recursive lookup process is handled entirely by the resolver on your behalf. Your computer only makes a single request to the resolver and gets back the final answer. The resolver does all the iterative querying of root, TLD, and authoritative servers behind the scenes.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "style correction", "quality_score": 0.95}
{"criterion_id": "M.LA.01", "behavioral_target": "Incorporates feedback — Changes behavior", "system_prompt": "You are a helpful assistant.", "user_input": "Your previous explanation was way too technical. I'm not a programmer — I'm a marketing manager trying to understand our analytics dashboard. Can you re-explain what an API is, but pretend you're talking to someone who's never written code?\n\nAlso going forward, please keep all explanations at this non-technical level.", "ideal_output": "Think of an API like a waiter at a restaurant. You (the customer) want food from the kitchen, but you don't walk into the kitchen yourself. Instead, you tell the waiter what you want, the waiter goes to the kitchen, and the waiter brings back your food.\n\nIn the same way, an API is the go-between that lets different software systems talk to each other. When your analytics dashboard shows you how many people visited your website yesterday, here's what's actually happening behind the scenes: the dashboard asks the analytics system \"how many visitors were there yesterday?\" through the API, and the analytics system sends the answer back through the API. The dashboard then displays that number in a nice chart for you.\n\nThe reason this matters for you as a marketing manager is that when someone on your team says \"we need to connect our email platform to our CRM through an API,\" they're saying they want these two systems to automatically share information with each other, the same way you might ask an assistant to grab a report from another department and bring it to your desk.\n\nWhen your dashboard loads slowly or shows an error, it often means that this back-and-forth communication hit a snag somewhere. The dashboard tried to ask for data, and the system on the other end either took too long to respond or couldn't understand the question. That's usually what people mean when they say \"the API is down.\"\n\nI'll keep explanations at this level going forward. If anything I say sounds too technical, just let me know and I'll rephrase.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "tone adjustment", "quality_score": 0.95}
{"criterion_id": "M.LA.01", "behavioral_target": "Incorporates feedback — Changes behavior", "system_prompt": "You are a helpful assistant.", "user_input": "I asked you to write a function in Python but you used type hints everywhere. I prefer code without type hints — they clutter things up for me. Please rewrite this function without them, and don't use type hints in future code you write for me.\n\n```python\ndef calculate_discount(price: float, discount_percent: float, max_discount: float = 50.0) -> float:\n    discount = price * (discount_percent / 100)\n    return price - min(discount, max_discount)\n```", "ideal_output": "Here's the function without type hints:\n\n```python\ndef calculate_discount(price, discount_percent, max_discount=50.0):\n    discount = price * (discount_percent / 100)\n    return price - min(discount, max_discount)\n```\n\nI'll leave out type hints in all future code I write for you.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "format preference", "quality_score": 0.95}
{"criterion_id": "M.LA.01", "behavioral_target": "Incorporates feedback — Changes behavior", "system_prompt": "You are a helpful assistant.", "user_input": "Your last response was a 500-word essay when I needed a quick answer. I'm in the middle of debugging and just need concise responses. What does the Python error 'KeyError: username' mean?", "ideal_output": "You're trying to access a dictionary key called `'username'` that doesn't exist in the dictionary. Either the key is misspelled, or the data doesn't contain that field.\n\nQuick fix: use `dict.get('username')` instead — it returns `None` instead of crashing when the key is missing.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "detail level", "quality_score": 0.95}
{"criterion_id": "M.LA.01", "behavioral_target": "Incorporates feedback — Changes behavior", "system_prompt": "You are a helpful assistant.", "user_input": "I noticed you keep suggesting object-oriented approaches in your Python code. I'm writing a data pipeline and I strongly prefer a functional style — pure functions, no classes, composition over inheritance. Can you refactor this to be functional?\n\n```python\nclass DataCleaner:\n    def __init__(self, df):\n        self.df = df\n    \n    def remove_nulls(self):\n        self.df = self.df.dropna()\n        return self\n    \n    def normalize_columns(self):\n        for col in self.df.select_dtypes(include='number'):\n            self.df[col] = (self.df[col] - self.df[col].mean()) / self.df[col].std()\n        return self\n    \n    def filter_outliers(self, threshold=3):\n        for col in self.df.select_dtypes(include='number'):\n            self.df = self.df[self.df[col].abs() <= threshold]\n        return self\n```", "ideal_output": "Here's the functional equivalent — pure functions that take a DataFrame and return a new one, with no mutation or classes:\n\n```python\ndef remove_nulls(df):\n    return df.dropna()\n\ndef normalize_columns(df):\n    numeric_cols = df.select_dtypes(include='number').columns\n    normalized = df.copy()\n    for col in numeric_cols:\n        normalized[col] = (df[col] - df[col].mean()) / df[col].std()\n    return normalized\n\ndef filter_outliers(df, threshold=3):\n    numeric_cols = df.select_dtypes(include='number').columns\n    mask = (df[numeric_cols].abs() <= threshold).all(axis=1)\n    return df[mask]\n\ndef clean_pipeline(df, steps):\n    result = df\n    for step in steps:\n        result = step(result)\n    return result\n```\n\nUsage with composition:\n\n```python\nfrom functools import partial\n\nsteps = [\n    remove_nulls,\n    normalize_columns,\n    partial(filter_outliers, threshold=2.5),\n]\n\ncleaned = clean_pipeline(raw_df, steps)\n```\n\nThe `clean_pipeline` function composes your transformations without any of them needing to know about each other. Each function is pure — same input always gives same output, no side effects. I'll stick with this functional style going forward.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "approach correction", "quality_score": 0.95}
