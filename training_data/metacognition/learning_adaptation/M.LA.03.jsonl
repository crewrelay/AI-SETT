{"criterion_id": "M.LA.03", "behavioral_target": "Generalizes from examples — Pattern extraction", "system_prompt": "You are a helpful assistant.", "user_input": "Here are three API endpoints from our codebase:\n\n```python\n@app.post('/users')\nasync def create_user(data: UserCreate):\n    try:\n        user = await db.users.insert(data.dict())\n        await cache.invalidate('users_list')\n        await events.emit('user.created', user)\n        return {'status': 'ok', 'data': user}\n    except DuplicateError:\n        return {'status': 'error', 'message': 'User already exists'}, 409\n\n@app.post('/orders')\nasync def create_order(data: OrderCreate):\n    try:\n        order = await db.orders.insert(data.dict())\n        await cache.invalidate('orders_list')\n        await events.emit('order.created', order)\n        return {'status': 'ok', 'data': order}\n    except InsufficientFundsError:\n        return {'status': 'error', 'message': 'Insufficient funds'}, 400\n\n@app.post('/products')\nasync def create_product(data: ProductCreate):\n    try:\n        product = await db.products.insert(data.dict())\n        await cache.invalidate('products_list')\n        await events.emit('product.created', product)\n        return {'status': 'ok', 'data': product}\n    except DuplicateError:\n        return {'status': 'error', 'message': 'Product already exists'}, 409\n```\n\nI need to add a create endpoint for \"invoices\". Can you write it?", "ideal_output": "I can see the pattern in your existing endpoints. Every create endpoint follows the same structure:\n\n1. Insert into the corresponding database collection\n2. Invalidate the list cache for that entity\n3. Emit a `{entity}.created` event\n4. Return the created object in `{'status': 'ok', 'data': ...}` format\n5. Catch the domain-specific error and return it with an appropriate status code\n\nFollowing that pattern:\n\n```python\n@app.post('/invoices')\nasync def create_invoice(data: InvoiceCreate):\n    try:\n        invoice = await db.invoices.insert(data.dict())\n        await cache.invalidate('invoices_list')\n        await events.emit('invoice.created', invoice)\n        return {'status': 'ok', 'data': invoice}\n    except DuplicateError:\n        return {'status': 'error', 'message': 'Invoice already exists'}, 409\n```\n\nI used `DuplicateError` as the exception since invoices likely have unique invoice numbers, similar to users and products. If invoices have a different failure mode (e.g., `InvalidClientError` if the referenced client doesn't exist), swap that in with the appropriate message and status code.\n\nI'll also note that this pattern is very consistent across your codebase, which means it could be extracted into a generic factory function if you find yourself adding many more entities. But that's a separate refactoring decision — for now, matching the existing pattern is the right call.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "code pattern", "quality_score": 0.95}
{"criterion_id": "M.LA.03", "behavioral_target": "Generalizes from examples — Pattern extraction", "system_prompt": "You are a helpful assistant.", "user_input": "Here are some example product descriptions I've written that I like:\n\n\"The Meridian desk lamp brings warm, focused light exactly where you need it. Its brushed brass arm pivots 180 degrees, letting you direct illumination across your workspace without moving the base. Weighs just 3.2 pounds.\"\n\n\"Our Cascade water bottle keeps drinks cold for 24 hours or hot for 12. The double-wall vacuum insulation means no condensation on the outside, no burning your hands. Fits standard cup holders. Dishwasher safe.\"\n\n\"The Ember mug heats your coffee to the exact temperature you set in the app, then keeps it there until you're done. No more lukewarm sips halfway through a meeting. Battery lasts 90 minutes on a full charge.\"\n\nNow write one for a noise-cancelling headphone product called \"Halo Pro\".", "ideal_output": "The Halo Pro blocks outside noise so completely you'll forget you're wearing headphones. Adaptive noise cancellation adjusts in real time — it handles a loud subway and a quiet office without you touching a button. Transparency mode lets voices through when you need them, with a double-tap on either ear cup.\n\nBattery runs 40 hours with noise cancellation on. Charges to 50% in 15 minutes if you're in a rush. The memory foam ear cushions stay comfortable through a full workday. Weighs 8.8 ounces.\n\nI matched the patterns I noticed in your writing: lead with the core benefit as an experience (not a spec), follow with the technical details that explain how it delivers that benefit, use short declarative sentences, end with concrete specs (weight, battery, time), and keep the tone direct without marketing superlatives. No words like \"revolutionary\" or \"game-changing\" — your style lets the product speak through what it does.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "writing style", "quality_score": 0.95}
{"criterion_id": "M.LA.03", "behavioral_target": "Generalizes from examples — Pattern extraction", "system_prompt": "You are a helpful assistant.", "user_input": "I've been manually mapping these error codes to user messages:\n\nE001 -> \"Your session has expired. Please log in again.\"\nE002 -> \"You don't have permission to access this resource.\"\nE003 -> \"The requested item was not found.\"\nE004 -> \"Your request couldn't be processed. Please try again.\"\nE005 -> \"Too many requests. Please wait a moment.\"\n\nI need to add messages for E006 (payment failed), E007 (file too large), and E008 (maintenance mode). Can you write them in the same style?", "ideal_output": "Following the pattern of your existing messages — direct, user-friendly, no error codes shown to the user, and each ending with a brief action or context:\n\nE006 -> \"Your payment could not be processed. Please check your card details and try again.\"\nE007 -> \"The file you selected is too large to upload. Please choose a smaller file.\"\nE008 -> \"We're currently performing scheduled maintenance. Please check back shortly.\"\n\nThe patterns I extracted from your examples: second person (\"your,\" \"you\"), present tense, one sentence describing what went wrong followed by one sentence suggesting what to do next (except where no action is needed), no technical jargon, and a period at the end rather than an exclamation mark. Your messages avoid being apologetic (no \"sorry\" or \"oops\") while still being polite and helpful.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "data pattern", "quality_score": 0.95}
{"criterion_id": "M.LA.03", "behavioral_target": "Generalizes from examples — Pattern extraction", "system_prompt": "You are a helpful assistant.", "user_input": "Here's how our infrastructure configs look:\n\n```yaml\nservices:\n  auth-service:\n    image: mycompany/auth:v2.3.1\n    replicas: 3\n    cpu: 500m\n    memory: 512Mi\n    healthcheck: /health\n    env:\n      - DB_HOST=auth-db.internal\n      - REDIS_HOST=cache.internal\n\n  user-service:\n    image: mycompany/users:v1.8.0\n    replicas: 2\n    cpu: 250m\n    memory: 256Mi\n    healthcheck: /health\n    env:\n      - DB_HOST=users-db.internal\n      - REDIS_HOST=cache.internal\n```\n\nAdd a config for our new notification-service.", "ideal_output": "Following your configuration pattern:\n\n```yaml\n  notification-service:\n    image: mycompany/notifications:v1.0.0\n    replicas: 2\n    cpu: 250m\n    memory: 256Mi\n    healthcheck: /health\n    env:\n      - DB_HOST=notifications-db.internal\n      - REDIS_HOST=cache.internal\n```\n\nPatterns I matched from your existing configs: image naming follows `mycompany/{service-name}:{version}`, every service gets a `/health` healthcheck, each service has its own database host following `{service}-db.internal`, all services share `cache.internal` for Redis, and resource allocation scales with the service's expected load (auth with 3 replicas and more resources, less critical services with 2 replicas and lighter allocation).\n\nI set it to v1.0.0 since it's new, gave it the same resources as user-service since notification services are typically lightweight, and 2 replicas for availability. Adjust the version tag and resources based on your actual deployment.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "config pattern", "quality_score": 0.95}
{"criterion_id": "M.LA.03", "behavioral_target": "Generalizes from examples — Pattern extraction", "system_prompt": "You are a helpful assistant.", "user_input": "Here's how we write tests in our project:\n\n```python\nclass TestUserCreation:\n    def test_creates_user_with_valid_data(self, client, db):\n        response = client.post('/api/users', json={\n            'name': 'Alice', 'email': 'alice@example.com'\n        })\n        assert response.status_code == 201\n        assert response.json['data']['name'] == 'Alice'\n        assert db.users.count() == 1\n\n    def test_rejects_duplicate_email(self, client, db, existing_user):\n        response = client.post('/api/users', json={\n            'name': 'Bob', 'email': existing_user.email\n        })\n        assert response.status_code == 409\n        assert 'already exists' in response.json['message']\n        assert db.users.count() == 1\n\n    def test_rejects_missing_email(self, client):\n        response = client.post('/api/users', json={'name': 'Charlie'})\n        assert response.status_code == 422\n        assert 'email' in response.json['message']\n```\n\nWrite tests for product creation at POST /api/products (fields: name, price, category).", "ideal_output": "Following your test structure and assertion style:\n\n```python\nclass TestProductCreation:\n    def test_creates_product_with_valid_data(self, client, db):\n        response = client.post('/api/products', json={\n            'name': 'Widget', 'price': 29.99, 'category': 'tools'\n        })\n        assert response.status_code == 201\n        assert response.json['data']['name'] == 'Widget'\n        assert db.products.count() == 1\n\n    def test_rejects_duplicate_name(self, client, db, existing_product):\n        response = client.post('/api/products', json={\n            'name': existing_product.name, 'price': 19.99, 'category': 'tools'\n        })\n        assert response.status_code == 409\n        assert 'already exists' in response.json['message']\n        assert db.products.count() == 1\n\n    def test_rejects_missing_price(self, client):\n        response = client.post('/api/products', json={\n            'name': 'Gadget', 'category': 'tools'\n        })\n        assert response.status_code == 422\n        assert 'price' in response.json['message']\n\n    def test_rejects_negative_price(self, client):\n        response = client.post('/api/products', json={\n            'name': 'Gadget', 'price': -5.00, 'category': 'tools'\n        })\n        assert response.status_code == 422\n        assert 'price' in response.json['message']\n\n    def test_rejects_missing_category(self, client):\n        response = client.post('/api/products', json={\n            'name': 'Gadget', 'price': 29.99\n        })\n        assert response.status_code == 422\n        assert 'category' in response.json['message']\n```\n\nI matched your patterns: pytest class grouping by entity, fixtures for `client`, `db`, and `existing_{entity}`, JSON payload via `json=`, asserting status code first then response body then database state, using `in` for message assertions rather than exact string matching, and test names following `test_{action}_{condition}` format. I added a negative price test since price has a validity constraint that email doesn't, but otherwise kept the same test coverage structure.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "test pattern", "quality_score": 0.95}
