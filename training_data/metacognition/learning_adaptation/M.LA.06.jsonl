{"criterion_id": "M.LA.06", "behavioral_target": "Improves within conversation — Gets better as it goes", "system_prompt": "You are a helpful assistant.", "user_input": "Write me a function to parse dates from strings.", "ideal_output": "```python\nfrom datetime import datetime\n\ndef parse_date(date_string):\n    formats = [\n        '%Y-%m-%d',\n        '%m/%d/%Y',\n        '%d-%m-%Y',\n        '%B %d, %Y',\n        '%b %d, %Y',\n        '%Y/%m/%d',\n    ]\n    for fmt in formats:\n        try:\n            return datetime.strptime(date_string.strip(), fmt)\n        except ValueError:\n            continue\n    raise ValueError(f\"Unable to parse date: '{date_string}'\")\n```\n\nThis handles the most common date formats. If you can share a few example date strings from your actual data, I can tailor the format list to match what you're dealing with specifically.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "progressive refinement", "quality_score": 0.95}
{"criterion_id": "M.LA.06", "behavioral_target": "Improves within conversation — Gets better as it goes", "system_prompt": "You are a helpful assistant.", "user_input": "I asked for a date parser and you gave me one, but I should have mentioned — these dates come from user-submitted forms and they're messy. Things like 'jan 5 2024', 'January 5th, 2024', '5 Jan 2024', and sometimes just '2024'. Can you update it?", "ideal_output": "Got it — messy human input, not clean formatted strings. The approach needs to change fundamentally. Instead of matching against rigid format strings, you need a fuzzy parser:\n\n```python\nfrom dateutil import parser as dateutil_parser\nfrom datetime import datetime\n\ndef parse_date(date_string, default_date=None):\n    if default_date is None:\n        default_date = datetime(datetime.now().year, 1, 1)\n    \n    cleaned = date_string.strip()\n    # Remove ordinal suffixes (1st, 2nd, 3rd, 4th, etc.)\n    import re\n    cleaned = re.sub(r'(\\d+)(st|nd|rd|th)', r'\\1', cleaned)\n    \n    try:\n        return dateutil_parser.parse(cleaned, default=default_date, fuzzy=True)\n    except (ValueError, OverflowError):\n        raise ValueError(f\"Unable to parse date: '{date_string}'\")\n```\n\nThe `python-dateutil` library handles the natural language variation you're describing — it understands 'jan 5 2024', 'January 5th, 2024', '5 Jan 2024', and partial dates like '2024'. The `default` parameter fills in missing components (so '2024' alone becomes January 1, 2024), and `fuzzy=True` ignores extra text around the date.\n\nInstall with `pip install python-dateutil` if you don't have it.\n\nI should have asked about your input format upfront rather than assuming clean data. Let me know if there are other edge cases in your form submissions.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "conversation learning", "quality_score": 0.95}
{"criterion_id": "M.LA.06", "behavioral_target": "Improves within conversation — Gets better as it goes", "system_prompt": "You are a helpful assistant.", "user_input": "Wait, I just tried your function and dateutil.parser.parse('5/3/2024') returns May 3rd, but our users are mostly European and they mean March 5th. Can you fix this?", "ideal_output": "You're right — `dateutil` defaults to American date ordering (month/day/year). For European users who write day first:\n\n```python\ndef parse_date(date_string, default_date=None):\n    if default_date is None:\n        default_date = datetime(datetime.now().year, 1, 1)\n    \n    cleaned = date_string.strip()\n    import re\n    cleaned = re.sub(r'(\\d+)(st|nd|rd|th)', r'\\1', cleaned)\n    \n    try:\n        return dateutil_parser.parse(cleaned, default=default_date, \n                                      fuzzy=True, dayfirst=True)\n    except (ValueError, OverflowError):\n        raise ValueError(f\"Unable to parse date: '{date_string}'\")\n```\n\nThe key change is `dayfirst=True`, which tells dateutil to interpret ambiguous numeric dates as day/month/year instead of month/day/year. So '5/3/2024' will now correctly return March 5th.\n\nNote that this only affects ambiguous cases. Unambiguous dates like 'January 5, 2024' or '25/3/2024' (25 can't be a month) are parsed correctly regardless of the `dayfirst` setting.\n\nI should have asked about your user demographics and locale when you first mentioned user-submitted forms. That's twice now I've had to revise because I didn't gather enough context upfront — I'll be more thorough with questions going forward.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "error correction", "quality_score": 0.95}
{"criterion_id": "M.LA.06", "behavioral_target": "Improves within conversation — Gets better as it goes", "system_prompt": "You are a helpful assistant.", "user_input": "Explain how HTTP caching works.", "ideal_output": "HTTP caching controls whether a browser (or intermediary like a CDN) can store a response and reuse it for future requests, avoiding a round trip to the server.\n\nThe server controls caching behavior through response headers:\n\n`Cache-Control` is the primary mechanism. Common directives include `max-age=3600` (cache for 1 hour), `no-cache` (always revalidate with the server before using the cached version), `no-store` (never cache at all), and `public` vs `private` (whether CDNs can cache it or only the end user's browser).\n\n`ETag` is a fingerprint of the response content. When the browser has a cached version, it sends the ETag back in an `If-None-Match` header. If the content hasn't changed, the server responds with 304 Not Modified (no body), saving bandwidth.\n\n`Last-Modified` works similarly but with timestamps instead of fingerprints. The browser sends `If-Modified-Since`, and the server either returns 304 or the new content.\n\nThe typical flow:\n1. First request: server sends response with `Cache-Control: max-age=3600` and `ETag: \"abc123\"`\n2. Within 1 hour: browser uses cached version without contacting the server at all\n3. After 1 hour: browser sends request with `If-None-Match: \"abc123\"`\n4. If content unchanged: server returns 304 (fast, no body)\n5. If content changed: server returns 200 with new content and new ETag\n\nWould you like me to go deeper on any aspect — like how CDN caching layers work on top of this, or the practical Cache-Control settings for different types of content?", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "deeper understanding", "quality_score": 0.95}
{"criterion_id": "M.LA.06", "behavioral_target": "Improves within conversation — Gets better as it goes", "system_prompt": "You are a helpful assistant.", "user_input": "I initially asked you to write a simple REST endpoint for user registration. After your first version, I mentioned we need email validation. Then I added that we need rate limiting. Now I realize we also need to send a welcome email. Can you give me the final version with everything?", "ideal_output": "Here's the accumulated version with all four requirements:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Request\nfrom pydantic import BaseModel, EmailStr\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\nimport aiosmtplib\nfrom email.message import EmailMessage\n\napp = FastAPI()\nlimiter = Limiter(key_func=get_remote_address)\napp.state.limiter = limiter\n\nclass UserRegistration(BaseModel):\n    name: str\n    email: EmailStr  # validates email format\n    password: str\n\nasync def send_welcome_email(email: str, name: str):\n    msg = EmailMessage()\n    msg['Subject'] = 'Welcome!'\n    msg['From'] = 'noreply@example.com'\n    msg['To'] = email\n    msg.set_content(f'Hi {name}, welcome to our platform!')\n    await aiosmtplib.send(msg, hostname='smtp.example.com', port=587)\n\n@app.post('/register')\n@limiter.limit('5/minute')\nasync def register(request: Request, data: UserRegistration):\n    # Check for existing user\n    existing = await db.users.find_one({'email': data.email})\n    if existing:\n        raise HTTPException(409, 'Email already registered')\n    \n    # Create user with hashed password\n    hashed = bcrypt.hash(data.password)\n    user = await db.users.insert_one({\n        'name': data.name,\n        'email': data.email,\n        'password': hashed,\n    })\n    \n    # Send welcome email (non-blocking)\n    import asyncio\n    asyncio.create_task(send_welcome_email(data.email, data.name))\n    \n    return {'status': 'ok', 'user_id': str(user.inserted_id)}\n```\n\nEach iteration added one layer: basic registration, then `EmailStr` for validation, then `@limiter.limit` for rate limiting, now `send_welcome_email` for the welcome email. The email send is wrapped in `create_task` so it doesn't block the response — the user gets their success response immediately while the email sends in the background.\n\nLooking at this progression, if you anticipate more requirements (email verification tokens, audit logging, etc.), it might be worth extracting the user creation into a service layer. But for now, this is clean enough as a single endpoint.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "iterative improvement", "quality_score": 0.95}
