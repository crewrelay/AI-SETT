{"criterion_id": "M.SS.04", "behavioral_target": "Prioritizes effectively — Most important first", "system_prompt": "You are a helpful assistant.", "user_input": "We just ran a security audit on our web application and got the following findings: (1) SQL injection in the admin search endpoint, (2) missing CSRF tokens on form submissions, (3) outdated jQuery version 2.1.4, (4) passwords hashed with MD5, (5) verbose error messages exposing stack traces in production, (6) no rate limiting on the login endpoint, (7) session cookies missing HttpOnly flag, (8) SSL certificate expiring in 10 days. We have one developer available this week. What order should we fix these?", "ideal_output": "I'll prioritize these by exploitability and impact, because with one developer and limited time, the order matters significantly.\n\n**Critical — fix today:**\n\n1. **SQL injection in admin search** — This is your most dangerous vulnerability. An attacker can extract your entire database, modify data, or potentially execute commands on the server. This is actively exploitable and the impact is total compromise. Fix this before anything else.\n\n2. **SSL certificate expiring in 10 days** — This isn't a security vulnerability yet, but it will become a site-breaking outage in 10 days. Certificate renewal is usually quick (especially with Let's Encrypt automation), so handle this immediately to remove the time pressure.\n\n**High priority — fix this week:**\n\n3. **Passwords hashed with MD5** — MD5 is effectively plaintext for password cracking. If your database is exfiltrated (especially possible given the SQL injection above), every user password is compromised within hours. Migrate to bcrypt or argon2. Note: this requires a migration strategy — you can't just rehash existing passwords. Hash new passwords with bcrypt, and rehash on next login for existing users.\n\n4. **No rate limiting on login** — Without rate limiting, attackers can brute-force credentials. Combined with MD5 passwords, this is especially dangerous. Implement rate limiting (e.g., 5 attempts per minute per IP/account).\n\n**Medium priority — fix next week:**\n\n5. **Missing CSRF tokens** — Exploitable but requires tricking an authenticated user into visiting a malicious page. Real risk, but requires more effort from an attacker than the items above.\n\n6. **Session cookies missing HttpOnly** — If an XSS vulnerability exists, cookies can be stolen via JavaScript. This is defense-in-depth — important, but a single-line configuration change.\n\n7. **Verbose error messages/stack traces** — Information disclosure helps attackers but isn't directly exploitable. Set your framework to production mode and implement a generic error handler.\n\n**Low priority — schedule for later:**\n\n8. **Outdated jQuery 2.1.4** — jQuery 2.x has known XSS vulnerabilities in specific methods, but exploitation depends on how you use it. Audit usage first, then upgrade. This is lowest priority because it's an indirect risk.\n\nThe ordering principle: direct exploitability + impact severity first, defense-in-depth measures second, indirect/conditional risks last.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "security triage", "quality_score": 0.95}
{"criterion_id": "M.SS.04", "behavioral_target": "Prioritizes effectively — Most important first", "system_prompt": "You are a helpful assistant.", "user_input": "I'm launching a SaaS product next month. Here's my pre-launch to-do list that I haven't started yet: set up monitoring and alerting, write comprehensive API documentation, implement email verification for signups, add GDPR cookie consent banner, build an onboarding tutorial for new users, set up automated backups, create a status page, implement Stripe billing integration. I can realistically do maybe 4-5 of these. Which ones and in what order?", "ideal_output": "Let me sort these by what blocks your launch versus what enhances it.\n\n**Must-do before launch (blocks revenue or creates legal/data risk):**\n\n1. **Stripe billing integration** — Without billing, you don't have a business. This is also typically the most complex integration, so start here.\n\n2. **Set up automated backups** — Losing customer data post-launch is a company-ending event. This is a few hours of setup, and the cost of not doing it is catastrophic.\n\n3. **Email verification for signups** — Without this, you'll accumulate fake accounts, your email deliverability will tank, and you can't reliably communicate with customers.\n\n4. **GDPR cookie consent banner** — If you have any EU users, this is a legal requirement. Use a library like cookie-consent or Osano — this is a half-day task.\n\n**Should-do if time allows:**\n\n5. **Monitoring and alerting** — You need basic uptime monitoring and error tracking. Free-tier tools work here. This is 2-3 hours.\n\n**Defer to post-launch:**\n\n6. **Onboarding tutorial** — Important for activation, but you need real users before you know what they actually struggle with.\n\n7. **Comprehensive API documentation** — Write minimal docs covering the main use cases. Comprehensive docs are a post-launch ongoing effort.\n\n8. **Status page** — With a handful of users, you can communicate outages directly. A status page becomes important when individual communication doesn't scale.\n\nThe prioritization logic: revenue-enabling first, data-protection second, legal compliance third, user experience enhancements last.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "startup priorities", "quality_score": 0.95}
{"criterion_id": "M.SS.04", "behavioral_target": "Prioritizes effectively — Most important first", "system_prompt": "You are a helpful assistant.", "user_input": "Our web app's page load time has gone from 2 seconds to 8 seconds over the past month. Looking at the browser dev tools, I see: the main JavaScript bundle is 2.3MB, we're making 47 API calls on page load, three of those API calls take 2+ seconds each, we're loading 12 web fonts, and our largest image is 4.5MB. The PM wants this fixed by end of week. What should I tackle first?", "ideal_output": "Let me quantify the impact of each issue to prioritize correctly, because some of these look bad but contribute little to the actual 8-second load time.\n\n**Impact analysis:**\n\nThe page went from 2s to 8s — a 6-second regression. I need to find where those 6 seconds went.\n\n- **Three API calls at 2+ seconds each**: If these run sequentially, they alone account for 6+ seconds. If they run in parallel, they account for 2+ seconds. Either way, this is probably your primary regression.\n\n- **2.3MB JavaScript bundle**: Large, but this downloads in parallel with other resources. On a typical connection, this is ~2 seconds to download, but it's cached after first visit. If it was this size a month ago too, it's not the cause of the regression.\n\n- **4.5MB image**: Downloads in parallel, doesn't block page interactivity. Annoying but not the cause of an 8-second load time.\n\n- **47 API calls**: The count is high, but if 44 of them are fast and they run in parallel, the count isn't the problem — the 3 slow ones are.\n\n- **12 web fonts**: Typically 20-50KB each. With font-display: swap, these don't block rendering.\n\n**Priority order:**\n\n1. **Fix the three slow API calls** — This is almost certainly where your 6-second regression lives. Investigate what changed: new database queries without indexes? New API dependencies? Removed caching?\n\n2. **Parallelize or batch API calls** — If those 47 calls include sequential chains that could be parallel, this reduces total waterfall time.\n\n3. **Compress the 4.5MB image** — Convert to WebP/AVIF and resize. A 5-minute fix with big bandwidth savings.\n\n4. **Split the JavaScript bundle** — Code-split by route so users only download code for the current page.\n\n5. **Font optimization** — Lowest impact on your specific problem.\n\nThe key insight: focus on what *changed* in the last month, not on everything that's suboptimal.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "performance triage", "quality_score": 0.95}
{"criterion_id": "M.SS.04", "behavioral_target": "Prioritizes effectively — Most important first", "system_prompt": "You are a helpful assistant.", "user_input": "I'm building a note-taking app and have the following features on my roadmap: real-time collaboration, offline mode, end-to-end encryption, markdown support, tagging and search, file attachments, dark mode, export to PDF, and browser extension for web clipping. I'm a solo developer. What should I build first?", "ideal_output": "For a note-taking app, I need to prioritize based on what makes the product usable at all versus what makes it competitive.\n\n**Tier 1 — Core functionality (build these first):**\n\n1. **Markdown support** — This is your core editor experience. Everything else depends on notes being writable and readable.\n\n2. **Tagging and search** — Notes are useless if you can't find them. Even with 20 notes, users need organization.\n\n**Tier 2 — Essential for adoption:**\n\n3. **Dark mode** — Note-taking apps are used for extended periods, often at night. Users will reject an app without dark mode before evaluating other features. Also easier to implement early than retrofit later.\n\n4. **Export to PDF** — Users won't adopt a note-taking app unless they can get their data out. Export is a trust signal.\n\n**Tier 3 — Competitive differentiation:**\n\n5. **End-to-end encryption** — Strong differentiator if central to your positioning.\n\n6. **Offline mode** — Important for reliability, but adds significant complexity (conflict resolution, sync queues).\n\n7. **File attachments** — Useful but not core.\n\n**Tier 4 — Growth features:**\n\n8. **Browser extension** — An acquisition channel, not a core feature.\n\n9. **Real-time collaboration** — The most complex feature on the list. Don't attempt until everything else works well.\n\nThe principle: a note-taking app must be fast, reliable, and pleasant for solo use before it can be anything else.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "feature prioritization", "quality_score": 0.95}
{"criterion_id": "M.SS.04", "behavioral_target": "Prioritizes effectively — Most important first", "system_prompt": "You are a helpful assistant.", "user_input": "Our e-commerce site just went down. Customer service is getting flooded with calls. Looking at our monitoring: the application servers show 100% CPU, the database connection pool is exhausted, there's a spike in traffic (10x normal), our CDN is returning 503s, and our Redis cache is showing memory warnings. We need to get back online. What do we do first?", "ideal_output": "This is an active incident. I'll order actions by what restores service fastest, not by root cause analysis.\n\n**Right now (next 5 minutes):**\n\n1. **Scale up application servers immediately.** If you're on auto-scaling, increase the maximum. If manual, spin up additional instances. 100% CPU with 10x traffic means you don't have enough compute.\n\n2. **Check if the traffic is legitimate.** Look at the traffic patterns: is this a DDoS, a bot, or a legitimate spike? Check access logs for suspicious patterns. If it's malicious, enable rate limiting or your CDN's DDoS protection immediately.\n\n**Next 15 minutes:**\n\n3. **Address the database connection pool.** The exhausted pool is likely a consequence of slow queries caused by high load. Kill long-running queries, increase pool size temporarily if your database can handle it.\n\n4. **Address Redis memory warnings.** If Redis hits its memory limit and starts evicting keys, your cache hit rate drops and more requests hit the database (cascading failure). Increase maxmemory or flush non-critical caches.\n\n**Once service is restored:**\n\n5. **Identify the trigger.** The 10x traffic spike is the key question. If legitimate, plan for capacity. If a marketing event no one told engineering about, that's a process problem. If a bot, implement permanent protections.\n\n**What I'm deliberately not prioritizing:**\n\nThe CDN 503s will resolve once the origin servers recover. Fixing CDN configuration now would be wasted effort. Similarly, investigating Redis memory root cause can wait until the site is stable.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "incident response", "quality_score": 0.95}
