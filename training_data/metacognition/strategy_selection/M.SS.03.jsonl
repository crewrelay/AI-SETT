{"criterion_id": "M.SS.03", "behavioral_target": "Evaluates options — Considers alternatives", "system_prompt": "You are a helpful assistant.", "user_input": "We're starting a new project — a B2B SaaS dashboard that will display complex data visualizations (charts, tables, maps) with real-time updates. The team knows React but we're open to other options. We need to choose between Next.js, Remix, and plain Vite+React. What should we use?", "ideal_output": "Let me evaluate each option against your specific requirements rather than giving a general recommendation.\n\n**Your key requirements as I understand them:**\n- Complex data visualizations (charts, tables, maps)\n- Real-time updates\n- B2B SaaS (implies: authenticated users, not public/SEO-critical)\n- Team knows React\n\n**Option 1: Next.js (App Router)**\n\nPros:\n- Largest ecosystem, most community resources\n- Server components could reduce bundle size for heavy visualization libraries\n- Built-in API routes for WebSocket upgrade endpoints\n- Vercel deployment is frictionless\n\nCons:\n- Server components add complexity that you may not need — B2B dashboards behind auth don't benefit much from SSR/SSG\n- The App Router's caching behavior can conflict with real-time data patterns (you'd spend time fighting the cache rather than using it)\n- Opinionated routing may constrain your dashboard layout patterns\n\n**Option 2: Remix**\n\nPros:\n- Excellent data loading patterns with nested routes\n- Progressive enhancement philosophy\n- Good error boundary handling per route segment\n\nCons:\n- Loader/action pattern is designed for request-response, not real-time. You'd be bolting WebSocket support onto a framework that wasn't designed for it.\n- Smaller ecosystem for visualization library integrations\n- Less community experience with heavy client-side interactivity patterns\n\n**Option 3: Vite + React (SPA)**\n\nPros:\n- Simplest mental model — no server/client boundary to manage\n- Full control over data fetching, caching, and real-time connection management\n- Visualization libraries (D3, Recharts, deck.gl) are designed for SPAs\n- No framework opinions fighting your real-time patterns\n- Fastest dev server and HMR\n\nCons:\n- No built-in routing (add React Router), no built-in API layer\n- Initial bundle size management is on you\n- No SSR, but for an authenticated B2B dashboard, this rarely matters\n\n**My evaluation:**\n\nFor an authenticated B2B dashboard with heavy visualization and real-time data, **Vite + React is the strongest choice**. The SSR/SSG capabilities of Next.js and Remix are solutions to problems you don't have (SEO, public page performance), while their abstractions would actively complicate your real-time data flow. The dashboard pattern — persistent WebSocket connections, client-side state management, heavy canvas/SVG rendering — is fundamentally a client-side concern.\n\nIf your requirements included public-facing marketing pages or SEO needs alongside the dashboard, I'd recommend Next.js with the dashboard section as a fully client-rendered route group.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "tech stack eval", "quality_score": 0.95}
{"criterion_id": "M.SS.03", "behavioral_target": "Evaluates options — Considers alternatives", "system_prompt": "You are a helpful assistant.", "user_input": "I need to store time-series sensor data from 500 IoT devices, each sending readings every 5 seconds. That's about 8.6 million data points per day. We need to query recent data (last 24 hours) frequently but also run analytics over historical data going back months. What database should I use?", "ideal_output": "This is a classic time-series workload with two distinct access patterns, so I need to evaluate options across both dimensions.\n\n**Scale check first:**\n- 500 devices x 1 reading/5 seconds = 100 inserts/second sustained\n- 8.6M rows/day -> ~260M rows/month -> ~3.1B rows/year\n- Assuming ~100 bytes per reading, that's ~860MB/day raw, ~310GB/year\n\nThis is moderate scale — large enough that general-purpose databases would struggle with the analytical queries, but not so large that you need a distributed cluster from day one.\n\n**Option 1: TimescaleDB (PostgreSQL extension)**\n\nPros:\n- Full SQL — your team likely knows it already\n- Automatic time-based partitioning (hypertables)\n- Continuous aggregates for pre-computed rollups\n- Compression achieves 10-20x for time-series data\n- Runs on standard PostgreSQL infrastructure\n- Can store relational metadata (device info, locations) in the same database\n\nCons:\n- Single-node PostgreSQL has ceiling around 10-20TB before needing Timescale's multi-node (which is more complex)\n- Not as fast as purpose-built columnar stores for large analytical scans\n\n**Option 2: InfluxDB**\n\nPros:\n- Purpose-built for time-series, extremely fast ingestion\n- Flux query language is powerful for time-series operations\n- Built-in retention policies and downsampling\n\nCons:\n- Flux is a new language to learn (InfluxQL is limited)\n- Open-source version (OSS) lacks clustering\n- Commercial licensing for HA/clustering is expensive\n- Can't easily join with relational data\n\n**Option 3: ClickHouse**\n\nPros:\n- Columnar storage — analytical queries over billions of rows are extremely fast\n- Excellent compression (often 20-40x for time-series)\n- SQL dialect, relatively familiar\n- Open source with no feature gating\n\nCons:\n- Not designed for point queries or frequent small updates\n- Operational complexity is higher\n- Overkill at your current scale; shines at 10x-100x your volume\n\n**Option 4: PostgreSQL with partitioning (no TimescaleDB)**\n\nPros:\n- Simplest infrastructure\n- Native table partitioning by time range works\n\nCons:\n- Manual partition management\n- No automatic compression or continuous aggregates\n- Query performance degrades faster at scale\n\n**My recommendation: TimescaleDB.**\n\nIt hits the sweet spot for your requirements: SQL familiarity, automatic time partitioning, compression for historical data, continuous aggregates for analytics, and the ability to keep device metadata in the same database. At ~310GB/year with compression, a single well-provisioned node handles this for years.\n\nI'd only choose ClickHouse if your analytical query patterns were extremely heavy (thousands of concurrent analytical queries) or if you expected 10x growth soon. And I'd only choose InfluxDB if ingestion speed were the bottleneck, which at 100 inserts/second it definitely isn't.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "database choice", "quality_score": 0.95}
{"criterion_id": "M.SS.03", "behavioral_target": "Evaluates options — Considers alternatives", "system_prompt": "You are a helpful assistant.", "user_input": "Our 8-person engineering team is struggling with code quality. We're debating between adding more code review requirements (currently one approval needed), implementing mandatory pair programming, or investing in automated testing. We have limited bandwidth so we can probably only focus on one approach right now. Which should we prioritize?", "ideal_output": "Each of these addresses code quality from a different angle. Let me evaluate them against what actually moves the needle for an 8-person team.\n\n**Option A: Stricter code reviews (e.g., 2 approvals required)**\n\nWhat it addresses: Catching logic errors, knowledge sharing, enforcing standards.\n\nLimitations:\n- Only catches issues a reviewer notices, which depends on reviewer attention and expertise\n- Adding a second required reviewer roughly doubles review turnaround time\n- For an 8-person team, this creates significant bottlenecks — finding two available reviewers with context becomes a scheduling problem\n- Doesn't prevent quality issues, only catches them after the code is written\n- Review fatigue is real: larger review requirements often lead to more rubber-stamping, not less\n\n**Option B: Mandatory pair programming**\n\nWhat it addresses: Real-time knowledge transfer, catching issues during writing, mentorship.\n\nLimitations:\n- Effectively halves your team's parallelism (4 pairs instead of 8 individuals)\n- For an 8-person team with limited bandwidth, this is a steep cost\n- Some tasks genuinely don't benefit from pairing (routine CRUD, well-understood changes)\n- Depends heavily on team compatibility and personality\n- Difficult to sustain long-term; most teams that mandate it eventually make it optional\n\n**Option C: Automated testing**\n\nWhat it addresses: Regression prevention, refactoring confidence, specification of expected behavior.\n\nLimitations:\n- Upfront investment before quality benefits materialize\n- Tests need maintenance as code changes\n- Doesn't catch design-level issues, only behavioral correctness\n\n**My evaluation:**\n\n**Invest in automated testing first.** Here's why:\n\n1. **It compounds over time.** Each test you write continues catching regressions forever. Reviews and pairing only catch issues at the moment they happen.\n\n2. **It's the highest-leverage option for a bandwidth-constrained team.** Reviews and pairing require ongoing human time. Tests require upfront time but then run automatically.\n\n3. **It makes the other options more effective later.** Code reviews are faster and more focused when reviewers can trust that tests cover behavioral correctness and focus their attention on design and logic instead. Pairing is more productive when there's a test suite to validate against.\n\n4. **It provides objective evidence.** \"The tests pass\" is less subjective than review opinions.\n\nPractically: start with integration tests on your most critical paths (authentication, payment, core business logic), not unit tests on everything. You'll get the most quality improvement per hour invested.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "team process", "quality_score": 0.95}
{"criterion_id": "M.SS.03", "behavioral_target": "Evaluates options — Considers alternatives", "system_prompt": "You are a helpful assistant.", "user_input": "I'm a solo developer launching a SaaS product. Expected initial traffic is low (maybe 100 users). I need to choose between AWS, a VPS like DigitalOcean/Hetzner, or a PaaS like Railway/Render. My app is a Next.js frontend with a Python FastAPI backend and PostgreSQL. Budget matters — I want to keep costs under $50/month initially.", "ideal_output": "Let me evaluate these against your actual constraints rather than general \"which cloud is best\" advice.\n\n**Your constraints:**\n- Solo developer (operations time is expensive — it's your time)\n- ~100 users initially (low traffic)\n- Next.js + FastAPI + PostgreSQL (two runtimes + database)\n- Under $50/month\n\n**Option 1: AWS (EC2 + RDS)**\n\nCost estimate: EC2 t3.small ($15) + RDS t3.micro ($13) + data transfer + load balancer ($16) = ~$50-70/month. Over budget before adding anything.\n\nPros: Infinitely scalable, full AWS ecosystem.\nCons: Expensive at small scale. RDS alone costs more than your entire budget on some configurations. As a solo dev, you'd spend significant time on IAM, VPC configuration, security groups, and other infrastructure concerns that don't ship features.\n\n**Verdict:** Overkill. AWS makes sense when you have dedicated DevOps or need specific AWS services. At 100 users, you're paying for infrastructure complexity you don't need.\n\n**Option 2: VPS (DigitalOcean/Hetzner)**\n\nCost estimate: Hetzner CX21 (2 vCPU, 4GB RAM) = 5 euros/month. DigitalOcean equivalent = $12/month. Run everything on one machine.\n\nPros: Cheapest option by far. Full control. Hetzner especially is exceptional value.\nCons: You're responsible for server maintenance, security updates, backups, SSL certificates, PostgreSQL administration, deployment pipelines. For a solo developer, a misconfigured backup or missed security update is a real risk.\n\n**Verdict:** Best value if you're comfortable with sysadmin work. But every hour spent on infrastructure is an hour not spent on product.\n\n**Option 3: PaaS (Railway/Render)**\n\nCost estimate: Railway — FastAPI service ($5-10) + Next.js service ($5-10) + PostgreSQL ($5-7) = ~$15-27/month. Render is similar.\n\nPros: Zero infrastructure management. Git push deploys. Managed PostgreSQL with automatic backups. SSL handled automatically. You focus entirely on code.\nCons: Less control. Potential for cost surprises if you scale. Vendor lock-in (mild — your code is portable, just the deployment config changes).\n\n**Verdict:** Best fit for your situation.\n\n**My recommendation: Railway or Render.**\n\nThe math here isn't just about hosting costs — it's about your time costs as a solo developer. If a VPS saves you $10/month but costs you 5 hours/month in maintenance, that's a terrible trade. At 100 users, your job is to find product-market fit, and PaaS lets you focus entirely on that.\n\nMigrate to a VPS or AWS later when either (a) your costs exceed $100/month on the PaaS and you want to optimize, or (b) you need infrastructure capabilities the PaaS doesn't offer. That's a good problem to have.\n\nBetween Railway and Render: Railway has slightly better DX and pricing transparency. Render has a more mature free tier if you want to test before paying.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "hosting evaluation", "quality_score": 0.95}
{"criterion_id": "M.SS.03", "behavioral_target": "Evaluates options — Considers alternatives", "system_prompt": "You are a helpful assistant.", "user_input": "I need to implement a search feature for an e-commerce site with about 500,000 products. Users should be able to search by product name, description, category, and attributes (color, size, etc.). We need typo tolerance, relevance ranking, and filtering. Should I build search with PostgreSQL full-text search, Elasticsearch, Algolia, or Meilisearch?", "ideal_output": "Let me evaluate each option against the specific characteristics of e-commerce search.\n\n**Option 1: PostgreSQL full-text search (tsvector/tsquery)**\n\nPros:\n- No additional infrastructure — uses your existing database\n- Good enough for basic keyword matching\n- GIN indexes handle 500K documents fine\n\nCons:\n- Typo tolerance is limited (you'd need pg_trgm extension, which gets slow for fuzzy matching at scale)\n- Relevance ranking is basic — ts_rank works but doesn't handle e-commerce-specific signals well (popularity, purchase frequency, margin)\n- No built-in faceted filtering (you'd build it with COUNT/GROUP BY queries, which gets complex)\n- Synonyms and stemming require manual dictionary management\n\nVerdict: Adequate if search is a secondary feature. For an e-commerce site where search directly drives revenue, the limitations hurt.\n\n**Option 2: Elasticsearch**\n\nPros:\n- Industry standard for search at scale, extremely powerful\n- Excellent relevance tuning, fuzzy matching, aggregations for facets\n- Handles complex query combinations well\n\nCons:\n- Significant operational overhead — JVM tuning, cluster management, index lifecycle\n- Resource-hungry (plan for 4GB+ RAM minimum)\n- For 500K documents, it's like using a freight train to deliver a package\n- Self-hosted costs or Elastic Cloud pricing ($95+/month for production)\n\nVerdict: Best search engine technically, but the operational burden is disproportionate to your scale.\n\n**Option 3: Algolia**\n\nPros:\n- Best-in-class search UX with InstantSearch widgets\n- Typo tolerance and relevance ranking work excellently out of the box\n- Zero operational overhead — fully managed\n- Fastest time-to-implement\n\nCons:\n- Pricing scales with search operations: 500K records on the Build plan is ~$110/month, and grows with query volume\n- Less flexibility for custom ranking algorithms\n- Data must be synced to their servers (adds integration complexity)\n- Vendor lock-in is real — their API is proprietary\n\nVerdict: Best developer experience and search quality, but the cost at scale is the concern.\n\n**Option 4: Meilisearch**\n\nPros:\n- Typo tolerance and relevance ranking are excellent (comparable to Algolia for most use cases)\n- Open source, self-hostable on modest hardware (500K docs runs well on 2GB RAM)\n- Simple REST API, very fast indexing\n- Faceted search and filtering built in\n- Meilisearch Cloud available if you want managed hosting (~$30/month)\n\nCons:\n- Smaller ecosystem than Elasticsearch\n- Less mature than Algolia for advanced e-commerce features (A/B testing, analytics, personalization)\n- Single-node only in open source (multi-node is Cloud-only)\n\nVerdict: Best balance of capability, cost, and operational simplicity.\n\n**My recommendation: Meilisearch.**\n\nFor 500K products, it provides the search quality your e-commerce site needs (typo tolerance, faceted filtering, relevance ranking) without Elasticsearch's operational burden or Algolia's cost scaling. Self-hosted on a small VPS, your ongoing cost is ~$5-10/month. If you want managed hosting, Meilisearch Cloud is still 3-4x cheaper than Algolia.\n\nI'd only choose Algolia if time-to-market is critical and you need InstantSearch widgets immediately, or Elasticsearch if you anticipate growing to millions of products with complex custom ranking requirements.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "algorithm selection", "quality_score": 0.95}
