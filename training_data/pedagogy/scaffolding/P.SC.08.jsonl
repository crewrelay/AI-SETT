{"criterion_id": "P.SC.08", "behavioral_target": "Adjusts scaffold to learner — More/less support as needed", "system_prompt": "You are a helpful assistant.", "user_input": "I want to build a website. I've never coded before. My friend said I should learn HTML and CSS. What's the difference between them? And what's JavaScript? Do I need all three?", "ideal_output": "Great questions — let me explain each one in plain terms.\n\n**HTML** is the content and structure. It's like the walls, rooms, and furniture in a house. It determines what's on the page: text, images, buttons, links. Here's what it looks like:\n\n```html\n<h1>My Website</h1>\n<p>Welcome! This is my first page.</p>\n```\n\nThat code would show a big heading and a paragraph of text. The tags in angle brackets (`<h1>`, `<p>`) tell the browser what each piece of content is.\n\n**CSS** is the styling — colors, fonts, spacing, layout. It's like paint, wallpaper, and interior design. Same house, different look:\n\n```css\nh1 {\n    color: blue;\n    font-size: 36px;\n}\n```\n\nThis would make your heading blue and 36 pixels tall.\n\n**JavaScript** makes things interactive — click a button and something happens, submit a form, show/hide content. It's like the electrical wiring and plumbing.\n\n**Do you need all three?** For a basic website, start with just HTML and CSS. You can build something that looks good without any JavaScript. Add JavaScript later when you want interactivity.\n\n**Your first step:** Create a file called `index.html` on your computer, type some HTML in it, and open it in your browser. You'll see a real web page you made. I can walk you through exactly what to type if you'd like to start right now.\n\nWe'll take this one step at a time — no rush.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "detect novice", "quality_score": 0.95}
{"criterion_id": "P.SC.08", "behavioral_target": "Adjusts scaffold to learner — More/less support as needed", "system_prompt": "You are a helpful assistant.", "user_input": "I'm implementing a custom memory allocator for a game engine. I've already written pool allocators and stack allocators, and now I need a general-purpose allocator that minimizes fragmentation. I'm considering a segregated free list approach with size classes but I'm wondering about the trade-offs versus a buddy allocator for my use case — lots of small, frequent allocations of varying sizes with occasional large allocations.", "ideal_output": "Given your use case — high frequency small allocations with varying sizes and occasional large ones — here are the trade-offs:\n\n**Segregated free list** is likely the better fit here. Advantages for your case:\n- O(1) allocation for small sizes (just pop from the appropriate free list)\n- Low fragmentation for the common case since each size class has its own pool\n- You can tune the size classes to match your actual allocation patterns\n- The occasional large allocation can fall through to a backing allocator (mmap/VirtualAlloc)\n\nThe main design decisions you'll face:\n- Size class granularity: 8-byte increments up to 256, then 16-byte, then exponential? Profile your allocation patterns to decide.\n- When a size class is empty: allocate a new slab from the OS or split from a larger class?\n- Thread safety: per-thread caches (like tcmalloc) add complexity but eliminate lock contention\n\n**Buddy allocator** downsides for your case:\n- Internal fragmentation — every allocation rounds up to a power of 2 (a 33-byte allocation wastes 31 bytes)\n- Splitting and coalescing overhead on the frequent small allocations\n- Better suited when allocations are more uniform in size\n\nOne hybrid approach worth considering: segregated free list for allocations under 4KB, buddy allocator for the rare large allocations. This plays to each algorithm's strengths.\n\nHave you profiled your current allocator to identify the actual allocation size distribution? That data would determine optimal size class boundaries.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "detect expert", "quality_score": 0.95}
{"criterion_id": "P.SC.08", "behavioral_target": "Adjusts scaffold to learner — More/less support as needed", "system_prompt": "You are a helpful assistant.", "user_input": "I want to learn about neural networks. I've been studying linear algebra and calculus in college, and I just finished a course on probability and statistics. I know Python well. Can you explain how backpropagation works?", "ideal_output": "Given your math background, I can explain this properly rather than through analogies.\n\nA neural network computes a function f(x; θ) where θ represents all the weights and biases. Training means finding θ that minimizes a loss function L(f(x; θ), y) over your training data.\n\n**The forward pass** computes the output layer by layer. For a simple network with one hidden layer:\n\n- z₁ = W₁x + b₁ (linear transformation)\n- a₁ = σ(z₁) (activation function applied element-wise)\n- z₂ = W₂a₁ + b₂\n- ŷ = σ(z₂)\n- L = loss(ŷ, y)\n\n**Backpropagation** is just the chain rule applied systematically.\n\nYou want ∂L/∂W₁ and ∂L/∂W₂ (the gradients with respect to each weight matrix). Starting from the output:\n\n∂L/∂z₂ = ∂L/∂ŷ · σ'(z₂)\n\n∂L/∂W₂ = ∂L/∂z₂ · a₁ᵀ\n\nThen propagate back:\n\n∂L/∂a₁ = W₂ᵀ · ∂L/∂z₂\n\n∂L/∂z₁ = ∂L/∂a₁ · σ'(z₁)  (element-wise)\n\n∂L/∂W₁ = ∂L/∂z₁ · xᵀ\n\nThe key insight: each layer's gradient depends on the gradient from the layer above it, which is why we compute backward. It's just recursive application of the multivariate chain rule.\n\nThe 'vanishing gradient problem' comes from multiplying many σ'(z) terms — if σ is sigmoid, σ' maxes out at 0.25, so deep networks multiply many values < 1, driving gradients to zero. ReLU partially solves this since ReLU'(z) = 1 for z > 0.\n\nWant me to walk through a concrete numerical example, or are you ready to implement this in NumPy?", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "adjust mid-convo", "quality_score": 0.95}
{"criterion_id": "P.SC.08", "behavioral_target": "Adjusts scaffold to learner — More/less support as needed", "system_prompt": "You are a helpful assistant.", "user_input": "Wait, I'm totally lost. You said 'instantiate the class' — what does that even mean? I thought a class was like a blueprint but I don't understand how you go from a blueprint to an actual thing. And what's 'self'? Why does every method need it?", "ideal_output": "I went too fast — let me back up and explain this more concretely.\n\nForget the word 'instantiate' for now. Let's use an example.\n\nImagine you design a form for a contact card. The form has blanks for: Name, Phone, Email. That form is a class — it defines what information a contact card can hold.\n\nBut the blank form isn't a contact. It's a template. When you fill in the form — 'Name: Alice, Phone: 555-1234' — now you have an actual contact. Filling in the form is what 'instantiate' means. The filled-in form is an 'instance' or 'object.'\n\nIn Python:\n```python\n# The blank form (the class)\nclass Contact:\n    def __init__(self, name, phone):\n        self.name = name\n        self.phone = phone\n\n# Filling in two forms (making two instances)\nalice = Contact(\"Alice\", \"555-1234\")\nbob = Contact(\"Bob\", \"555-5678\")\n```\n\nNow `alice` and `bob` are two separate contacts, each with their own name and phone.\n\n**What's `self`?** When Alice's contact card needs to refer to its own data, `self` is how it says 'my.' `self.name` means 'my name.' When you call `alice.name`, Python fills in `self` as `alice` automatically.\n\nThink of `self` as the contact card pointing at itself saying 'this one — my data, not Bob's.'\n\nDoes that make more sense? Let me know if 'self' still feels fuzzy and I'll show you with a more detailed example.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "scale down", "quality_score": 0.95}
{"criterion_id": "P.SC.08", "behavioral_target": "Adjusts scaffold to learner — More/less support as needed", "system_prompt": "You are a helpful assistant.", "user_input": "Yeah, I know what closures are — a function that captures variables from its enclosing scope. I've used them a lot in JavaScript. Can you skip the basics and show me something interesting about closures that I might not know?", "ideal_output": "Since you're comfortable with closures, here are some less obvious aspects:\n\n**1. Closures capture variables, not values.**\n```javascript\nfor (var i = 0; i < 3; i++) {\n    setTimeout(() => console.log(i), 100);\n}\n// Prints: 3, 3, 3 — not 0, 1, 2\n```\nAll three closures share the same `i` variable, which is 3 by the time they execute. You probably know the `let` fix (block scoping creates a new binding each iteration), but the underlying reason is that closures hold a reference to the variable's storage location, not a snapshot.\n\n**2. Closures and garbage collection.**\nIf a closure references even one variable from an outer scope, some engines retain the entire scope object. This can cause unexpected memory retention:\n```javascript\nfunction createHandler(largeData) {\n    let processed = transform(largeData);\n    return () => console.log(processed.summary);\n    // largeData may still be retained depending on the engine,\n    // even though the closure only uses 'processed'\n}\n```\nV8 is generally smart about this (it does scope analysis), but it's not guaranteed.\n\n**3. Closures as poor man's objects (and vice versa).**\nClosures and objects are duals of each other. A closure bundles functions with shared state; an object bundles state with associated functions. In fact, you can implement a full object system using only closures, and vice versa. This duality is why some languages (like Scheme) don't bother with classes at all.\n\n**4. Closure identity and equality.**\n```javascript\nfunction makeAdder(n) { return x => x + n; }\nconst add5a = makeAdder(5);\nconst add5b = makeAdder(5);\nadd5a === add5b // false — each call creates a new closure\n```\nThis matters when using closures as React dependencies, event listeners, or Map keys.\n\nAny of these directions worth exploring further?", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "scale up", "quality_score": 0.95}
