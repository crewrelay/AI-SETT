{"criterion_id": "P.MH.01", "behavioral_target": "Identifies common misconceptions — Knows typical errors", "system_prompt": "You are a helpful assistant.", "user_input": "I'm learning CSS and I set `margin: auto` on my div but it won't center vertically. I thought `margin: auto` centers things?", "ideal_output": "This is one of the most common CSS misconceptions. `margin: auto` does center elements, but only horizontally in normal flow — and only when the element has an explicit width.\n\nHere's why the vertical centering doesn't work: in normal document flow, the browser calculates the available horizontal space and splits it equally with `margin: auto`. But vertically, block elements don't have a fixed container height to calculate against by default — the container just grows to fit its content. There's no \"leftover\" vertical space to distribute.\n\nThe misconception comes from seeing `margin: 0 auto` used everywhere for horizontal centering and assuming it works the same way on both axes. It's a reasonable assumption, but CSS doesn't treat the two axes symmetrically in normal flow.\n\n**How to actually center vertically:**\n\nThe modern approach is flexbox on the parent:\n\n```css\n.parent {\n  display: flex;\n  align-items: center;     /* vertical centering */\n  justify-content: center; /* horizontal centering */\n  height: 100vh;           /* parent needs a height */\n}\n```\n\nInterestingly, `margin: auto` *does* work for vertical centering inside a flex container. So this also works:\n\n```css\n.parent {\n  display: flex;\n  height: 100vh;\n}\n.child {\n  margin: auto; /* centers both directions in flex */\n}\n```\n\nThe key insight: vertical centering requires the parent to have a defined height. Without it, there's no vertical space to center within.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "css misconception", "quality_score": 0.95}
{"criterion_id": "P.MH.01", "behavioral_target": "Identifies common misconceptions — Knows typical errors", "system_prompt": "You are a helpful assistant.", "user_input": "I deleted a file from my git repository by removing it from the folder. But when I clone the repo on another machine, the file is still there. I thought deleting it would remove it from git?", "ideal_output": "This is a common misunderstanding about how git tracks changes. Deleting a file from your filesystem doesn't automatically tell git to stop tracking it — you've only made a local change that git has noticed but hasn't recorded yet.\n\nWhat happened: you deleted the file from your working directory, but you didn't stage and commit that deletion. Git saw the file was missing (it would show as \"deleted\" in `git status`), but since you didn't commit that change, the file still exists in all previous commits and in the remote repository.\n\nThe misconception is thinking that git tracks your folder directly. It doesn't — git tracks *snapshots* (commits). Each commit is a complete snapshot of your project. Deleting a file only affects the next snapshot if you explicitly include that deletion.\n\n**What you need to do:**\n\n```bash\n# Option 1: Stage the deletion and commit\ngit add -u              # stages all modifications and deletions\ngit commit -m \"Remove unwanted file\"\ngit push\n\n# Option 2: Use git rm (deletes file AND stages the deletion)\ngit rm filename.txt\ngit commit -m \"Remove unwanted file\"\ngit push\n```\n\nAfter pushing, new clones won't have the file in the latest version. However, the file will still exist in the repository's history — anyone can see it in previous commits. If the file contained sensitive data (like passwords), you'd need to rewrite the git history entirely, which is a separate and more complex operation.\n\nAnother related misconception: adding a file to `.gitignore` after it's already tracked doesn't make git forget about it. You'd need to `git rm --cached filename` first, then add it to `.gitignore`.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "git misconception", "quality_score": 0.95}
{"criterion_id": "P.MH.01", "behavioral_target": "Identifies common misconceptions — Knows typical errors", "system_prompt": "You are a helpful assistant.", "user_input": "I made my JavaScript function async and added await, but it's still not waiting for the result. Here's my code:\n\n```javascript\nasync function getData() {\n  const result = await fetch('/api/data');\n  return result.json();\n}\n\nconst data = getData();\nconsole.log(data); // Promise { <pending> }\n```\n\nWhy is it showing a Promise instead of the data?", "ideal_output": "This is the most common misconception about async/await in JavaScript. Making a function `async` doesn't make the *caller* wait for it — it makes the code *inside* the function wait at `await` points. The function itself still returns a Promise to whoever calls it.\n\nHere's what's happening step by step:\n\n1. `getData()` is called and starts executing\n2. Inside, it correctly awaits the fetch\n3. But `getData` itself returns a Promise (all async functions do)\n4. Your `const data = getData()` captures that Promise, not the resolved value\n5. `console.log(data)` runs immediately, before the Promise resolves\n\nThe misconception is thinking `async/await` eliminates Promises. It doesn't — it's syntactic sugar *over* Promises. An async function always returns a Promise, and `await` only pauses execution *within* an async function, not in the calling code.\n\n**The fix — you need to await the call too:**\n\n```javascript\n// Option 1: await in another async function\nasync function main() {\n  const data = await getData();\n  console.log(data); // actual data\n}\nmain();\n\n// Option 2: use .then()\ngetData().then(data => {\n  console.log(data); // actual data\n});\n\n// Option 3: top-level await (in modules)\nconst data = await getData();\nconsole.log(data);\n```\n\nThere's also a subtle bug in your `getData` function: `result.json()` also returns a Promise, so you should `await` it too:\n\n```javascript\nasync function getData() {\n  const result = await fetch('/api/data');\n  return await result.json(); // await the JSON parsing\n}\n```\n\nThe `await` before `result.json()` isn't strictly necessary (returning a Promise from an async function auto-unwraps it), but it makes the intent clearer and helps with error handling.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "async misconception", "quality_score": 0.95}
{"criterion_id": "P.MH.01", "behavioral_target": "Identifies common misconceptions — Knows typical errors", "system_prompt": "You are a helpful assistant.", "user_input": "I'm checking if two lists are equal in Python and it's giving me weird results:\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b)  # True\nprint(a is b)  # False — why?\n```\n\nIf they're equal, why does `is` say they're not the same?", "ideal_output": "This is a fundamental misconception about identity vs. equality in Python, and it trips up almost every beginner.\n\n`==` checks **equality** — do these two objects have the same value?\n`is` checks **identity** — are these literally the same object in memory?\n\nYour two lists `a` and `b` contain the same elements (they're equal), but they're two separate list objects stored in different memory locations (they're not identical). Think of it like two identical copies of the same book — they have the same content (`==` is True), but they're physically different books (`is` is False).\n\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(id(a))  # e.g., 140234567890\nprint(id(b))  # e.g., 140234567950 — different memory address\n```\n\nIf you wanted them to be the same object:\n\n```python\na = [1, 2, 3]\nb = a            # b now points to the same object as a\nprint(a is b)    # True — same object\nb.append(4)\nprint(a)         # [1, 2, 3, 4] — modifying b also modifies a!\n```\n\nThe reason this misconception is so persistent is that it *does* work with small integers and short strings in CPython:\n\n```python\nx = 5\ny = 5\nprint(x is y)  # True — but this is an implementation detail!\n```\n\nCPython caches small integers (-5 to 256) and some strings, so `is` happens to return True for those. But relying on this is a bug waiting to happen.\n\n**The rule:** use `==` for value comparison (almost always what you want). Use `is` only for checking against `None`, `True`, or `False` — specifically `if x is None`, not `if x == None`.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "equality misconception", "quality_score": 0.95}
{"criterion_id": "P.MH.01", "behavioral_target": "Identifies common misconceptions — Knows typical errors", "system_prompt": "You are a helpful assistant.", "user_input": "I'm building a REST API and I use POST for creating resources and PUT for updating them. My colleague says I should use PATCH instead of PUT for updates. What's the difference? I thought PUT was for updates.", "ideal_output": "Your colleague is raising a real distinction, and it's one of the most commonly misunderstood aspects of REST APIs. Both PUT and PATCH are for updates, but they mean different things.\n\n**PUT means \"replace the entire resource.\"** When you send a PUT request, you're sending the complete new version of the resource. Any fields you don't include are set to null/default — the server replaces the whole thing.\n\n```http\n# User currently: {name: \"Alice\", email: \"alice@example.com\", age: 30}\n\nPUT /users/1\n{\"name\": \"Alice\", \"email\": \"newemail@example.com\"}\n\n# Result: {name: \"Alice\", email: \"newemail@example.com\", age: null}\n# age is gone because you didn't include it!\n```\n\n**PATCH means \"update only the specified fields.\"** You send just the changes, and everything else stays as-is.\n\n```http\nPATCH /users/1\n{\"email\": \"newemail@example.com\"}\n\n# Result: {name: \"Alice\", email: \"newemail@example.com\", age: 30}\n# age is preserved\n```\n\nThe misconception that \"PUT = update\" is widespread because many APIs use PUT but actually implement PATCH behavior (they only update the fields you send). This works in practice but is technically incorrect according to the HTTP spec.\n\n**What you should use depends on your use case:**\n\n- **PATCH** for most update operations, where users change one or two fields at a time (edit profile, update settings). This is what your colleague is recommending, and it's correct for most cases.\n- **PUT** when the client is managing the entire resource (form submissions where all fields are always sent, configuration files, replacing a document).\n\nIn practice, most modern APIs use PATCH for partial updates and POST for creation. PUT is less common but appropriate when the client sends the complete resource every time.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "http misconception", "quality_score": 0.95}
