{"criterion_id": "P.MH.04", "behavioral_target": "Contrasts misconception with correct — Shows difference clearly", "system_prompt": "You are a helpful assistant.", "user_input": "What's the difference between authentication and authorization? I keep using them interchangeably.", "ideal_output": "They're related but fundamentally different, and confusing them leads to security gaps. Let me contrast them clearly.\n\n**Authentication** answers: *\"Who are you?\"*\n**Authorization** answers: *\"What are you allowed to do?\"*\n\nA real-world analogy: when you show your ID at a building entrance, that's authentication (proving who you are). When the guard checks whether your name is on the list for the 5th floor, that's authorization (checking what you're allowed to access).\n\nIn software:\n\n| | Authentication | Authorization |\n|---|---|---|\n| Question | Are you who you claim to be? | Do you have permission for this? |\n| When | First (before authorization) | After authentication |\n| Mechanism | Passwords, biometrics, tokens | Roles, permissions, policies |\n| Failure response | 401 Unauthorized | 403 Forbidden |\n| Example | Login with email + password | Admin can delete users, regular users can't |\n\n**Why confusing them causes bugs:**\n\nA common mistake is checking only authentication (\"is this a valid logged-in user?\") without checking authorization (\"does this user have permission to view *this specific* resource?\"). This leads to a class of bugs called **insecure direct object references**: User A can access User B's data by changing the user ID in the URL, because the system verified they were logged in but didn't check *whose* data they were requesting.\n\n```python\n# Authentication only (insecure):\n@login_required\ndef view_profile(request, user_id):\n    return User.objects.get(id=user_id)  # any logged-in user can view any profile!\n\n# Authentication + Authorization (secure):\n@login_required\ndef view_profile(request, user_id):\n    if request.user.id != user_id and not request.user.is_admin:\n        return HttpResponseForbidden()\n    return User.objects.get(id=user_id)\n```\n\nNote the HTTP status codes: 401 means \"I don't know who you are\" (authentication failed). 403 means \"I know who you are, but you're not allowed to do this\" (authorization failed). Using the right status code helps clients handle errors correctly.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "auth concepts", "quality_score": 0.95}
{"criterion_id": "P.MH.04", "behavioral_target": "Contrasts misconception with correct — Shows difference clearly", "system_prompt": "You are a helpful assistant.", "user_input": "I keep mixing up parallelism and concurrency. Aren't they the same thing?", "ideal_output": "They're related but distinct concepts. The confusion is natural because they often occur together, but understanding the difference helps you choose the right tool.\n\n**Concurrency** = dealing with multiple things at once (structure)\n**Parallelism** = doing multiple things at once (execution)\n\nThe classic analogy: a single chef managing multiple dishes by switching between them is concurrent but not parallel. Two chefs each working on their own dish is parallel.\n\n**Concurrency without parallelism:**\n\nJavaScript's event loop is concurrent but single-threaded. It handles thousands of network requests \"at once\" by switching between them, but only one piece of JavaScript code runs at any given moment.\n\n```javascript\n// Concurrent, not parallel:\nawait Promise.all([\n  fetch('/api/users'),     // starts request, doesn't wait\n  fetch('/api/orders'),    // starts request, doesn't wait\n  fetch('/api/products'),  // starts request, doesn't wait\n]);\n// All three requests are in-flight simultaneously,\n// but the JS thread processes their responses one at a time\n```\n\n**Parallelism without concurrency:**\n\nA GPU processing a matrix multiplication runs the same operation on thousands of data points simultaneously. It's parallel (many computations at the same time) but not concurrent in the multitasking sense (it's doing one thing — the matrix multiplication).\n\n**Both together:**\n\nA web server running 8 worker processes, each handling multiple requests, is both concurrent (multiple requests per process) and parallel (multiple processes on different cores).\n\n**Why the distinction matters for your code:**\n\n| Problem type | What you need | Tool |\n|---|---|---|\n| Many network/IO operations | Concurrency | async/await, event loops, threading |\n| Heavy CPU computation | Parallelism | multiprocessing, worker threads, GPU |\n| Both | Both | Multiple processes with async IO each |\n\nUsing parallelism for IO problems wastes resources (threads sitting idle waiting for responses). Using concurrency for CPU problems doesn't help (you need actual parallel execution). Matching the tool to the problem type is why this distinction matters.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "concurrency models", "quality_score": 0.95}
{"criterion_id": "P.MH.04", "behavioral_target": "Contrasts misconception with correct — Shows difference clearly", "system_prompt": "You are a helpful assistant.", "user_input": "What's the difference between encryption, encoding, and hashing? My coworker said we should \"encrypt\" user IDs in URLs but I think he means encoding. Help me understand.", "ideal_output": "These three are commonly confused because they all transform data, but they serve fundamentally different purposes and have different security properties.\n\n**Encoding** = changing the format for compatibility. Not for security.\n\n```\nBase64: \"Hello\" → \"SGVsbG8=\"\nURL encoding: \"hello world\" → \"hello%20world\"\n```\n\nAnyone can decode it. There's no secret key. It's like translating between languages — anyone who knows the language can translate back. Your coworker probably means Base64 encoding user IDs, which would make `user/42` look like `user/NDI=`. This adds zero security — anyone can decode it instantly.\n\n**Encryption** = making data unreadable without a secret key. Reversible with the key.\n\n```\nAES: \"Hello\" + secret key → \"x7Fk2pQ...\" (gibberish)\nDecrypt: \"x7Fk2pQ...\" + same secret key → \"Hello\"\n```\n\nOnly someone with the key can read it. This IS for security. If you actually encrypted user IDs in URLs, only your server (which has the key) could read them.\n\n**Hashing** = creating a fixed-length fingerprint. Intentionally NOT reversible.\n\n```\nSHA-256: \"Hello\" → \"185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969\"\n```\n\nYou cannot get \"Hello\" back from the hash. This is used for passwords: you store the hash, and when someone logs in, you hash their input and compare hashes. If your database is stolen, attackers have hashes, not passwords.\n\n**The comparison table:**\n\n| | Purpose | Reversible? | Key needed? | Security? |\n|---|---|---|---|---|\n| Encoding | Format conversion | Yes, by anyone | No | None |\n| Encryption | Confidentiality | Yes, with key | Yes | Yes |\n| Hashing | Integrity/fingerprint | No | No | One-way only |\n\n**What your coworker probably needs:**\n\nIf the goal is to hide sequential user IDs (so people can't guess `user/43` from seeing `user/42`), use UUIDs instead of sequential integers. That's simpler and more robust than encoding or encrypting the IDs. If you genuinely need to obscure IDs in URLs, use a signed token (like a short JWT) or a non-sequential ID format like NanoID.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "encoding contrast", "quality_score": 0.95}
{"criterion_id": "P.MH.04", "behavioral_target": "Contrasts misconception with correct — Shows difference clearly", "system_prompt": "You are a helpful assistant.", "user_input": "I'm learning C and I'm confused about the stack and the heap. What's the difference and when do I use malloc?", "ideal_output": "The stack and heap are two regions of memory that your program uses, but they work very differently.\n\n**The stack — automatic, fast, limited:**\n\n```c\nvoid example() {\n    int x = 42;           // allocated on the stack\n    char name[100];       // allocated on the stack\n}   // x and name are automatically freed when the function returns\n```\n\nStack memory is managed for you. When you declare a variable inside a function, it goes on the stack. When the function returns, it's gone. No cleanup needed. Allocation is extremely fast (just moving a pointer).\n\nLimitations: stack memory is small (usually 1-8 MB), and the data only lives as long as the function that created it.\n\n**The heap — manual, flexible, your responsibility:**\n\n```c\nvoid example() {\n    int *data = malloc(1000 * sizeof(int));  // allocated on the heap\n    // ... use data ...\n    free(data);  // YOU must free it, or it leaks\n}\n```\n\nHeap memory is managed by you. You explicitly ask for it (malloc) and explicitly return it (free). It persists until you free it, regardless of which function created it. The heap is much larger (limited by available RAM).\n\n**When to use each:**\n\n| Use stack (local variables) | Use heap (malloc) |\n|---|---|\n| Small, fixed-size data | Large data (big arrays, structures) |\n| Only needed within this function | Data that outlives the function |\n| Known size at compile time | Size determined at runtime |\n| `int x = 5;` | `int *arr = malloc(n * sizeof(int));` |\n\n**Concrete example of when you need the heap:**\n\n```c\n// This DOESN'T work — returns pointer to stack memory that's gone:\nint* bad_function() {\n    int result[100];\n    return result;  // DANGER: result is freed when function returns!\n}\n\n// This WORKS — heap memory persists after the function returns:\nint* good_function() {\n    int *result = malloc(100 * sizeof(int));\n    return result;  // caller must free() this later\n}\n```\n\nThe rule of thumb: use local variables (stack) by default. Use malloc (heap) when you need data to outlive the current function or when the size is too large or too dynamic for the stack.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "stack vs heap", "quality_score": 0.95}
{"criterion_id": "P.MH.04", "behavioral_target": "Contrasts misconception with correct — Shows difference clearly", "system_prompt": "You are a helpful assistant.", "user_input": "I keep hearing that microservices are better than monoliths. What's the actual difference and when should I use each?", "ideal_output": "\"Microservices are better\" is an oversimplification that has led a lot of teams to adopt unnecessary complexity. Let me contrast them clearly.\n\n**Monolith:** Your entire application is one codebase, one deployable unit.\n\n```\n[Single Application]\n├── User management\n├── Order processing\n├── Payment handling\n├── Notification system\n└── Reporting\n```\n\nAll code runs in one process, shares one database, deploys together.\n\n**Microservices:** Each feature is a separate application with its own codebase and database.\n\n```\n[User Service] ←→ [Order Service] ←→ [Payment Service]\n     ↓                  ↓                    ↓\n [User DB]          [Order DB]          [Payment DB]\n\n[Notification Service]    [Reporting Service]\n        ↓                        ↓\n  [Notification DB]         [Report DB]\n```\n\nEach service runs independently, communicates over the network, deploys separately.\n\n**What microservices give you:**\n- Independent deployment: update payments without redeploying users\n- Independent scaling: scale the order service without scaling reporting\n- Technology freedom: write the payment service in Go, the reporting service in Python\n- Team autonomy: different teams own different services\n\n**What microservices cost you:**\n- Network calls instead of function calls (slower, can fail)\n- Distributed data management (no cross-service database joins, eventual consistency)\n- Operational overhead (monitoring, logging, tracing across services)\n- Debugging complexity (a bug might span multiple services)\n- Deployment infrastructure (container orchestration, service discovery)\n\n**When to use each:**\n\n| Monolith | Microservices |\n|---|---|\n| Small team (< 10 developers) | Large organization (50+ developers) |\n| New product finding its fit | Mature product with clear domain boundaries |\n| Simple deployment needs | Teams need to deploy independently |\n| Most startups | Large-scale systems with distinct scaling needs |\n\nThe best advice: start with a well-structured monolith (code organized by domain). If you later need the specific benefits microservices provide (independent deployment, independent scaling), extract services from the monolith one at a time. Going microservices-first is one of the most common over-engineering mistakes in software.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "microservices contrast", "quality_score": 0.95}
