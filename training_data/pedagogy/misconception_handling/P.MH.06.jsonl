{"criterion_id": "P.MH.06", "behavioral_target": "Prevents related misconceptions — Anticipates adjacent errors", "system_prompt": "You are a helpful assistant.", "user_input": "I just learned about CORS and now I understand why my frontend can't call my API. I'll just add `Access-Control-Allow-Origin: *` to fix it.", "ideal_output": "That will fix the immediate CORS error, but I want to flag a few related misconceptions before you deploy this, because `*` as a wildcard creates problems you'll hit next.\n\n**The immediate fix works, but here's what to watch for:**\n\n1. **`*` doesn't work with credentials.** If your frontend sends cookies or Authorization headers (which it almost certainly does for authenticated requests), the browser will reject responses with `Access-Control-Allow-Origin: *`. You'll get a different CORS error: \"Cannot use wildcard with credentials.\" You need to specify the exact origin instead:\n\n```\nAccess-Control-Allow-Origin: https://yourfrontend.com\nAccess-Control-Allow-Credentials: true\n```\n\n2. **Preflight requests.** When your frontend sends requests with headers like `Authorization` or `Content-Type: application/json`, the browser sends a preliminary OPTIONS request (called a preflight) before the actual request. If your server doesn't handle OPTIONS requests and return the CORS headers, the preflight fails and the actual request never happens. This confuses people who think \"I set the headers but it still doesn't work.\"\n\n3. **CORS is not security.** A common misconception after learning about CORS: it protects your API from unauthorized access. It doesn't. CORS is a browser policy — it only applies to browsers. Anyone can call your API with curl, Postman, or server-side code regardless of CORS settings. Your API still needs proper authentication and authorization.\n\n4. **Don't disable CORS in production.** Some developers get frustrated and add `*` everywhere or use a CORS proxy. In development, that's fine. In production, set specific allowed origins:\n\n```python\n# Don't do this in production:\nCORS(app, origins='*')\n\n# Do this:\nCORS(app, origins=['https://yourfrontend.com', 'https://staging.yourfrontend.com'])\n```\n\nSo yes, set the CORS headers, but be specific about origins, handle OPTIONS preflight requests, and remember that CORS is a browser convenience feature, not a security mechanism for your API.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "cors prevention", "quality_score": 0.95}
{"criterion_id": "P.MH.06", "behavioral_target": "Prevents related misconceptions — Anticipates adjacent errors", "system_prompt": "You are a helpful assistant.", "user_input": "I just implemented JWT authentication! I'm storing the token in localStorage and sending it in the Authorization header. It's working great.", "ideal_output": "That works, but there are several related pitfalls that commonly follow this implementation. Let me flag them before they become problems.\n\n**1. localStorage is vulnerable to XSS.**\n\nAny JavaScript running on your page can read localStorage. If your site has a cross-site scripting (XSS) vulnerability — even in a third-party script like an analytics library — an attacker can steal the JWT and impersonate the user.\n\nThe more secure alternative is an httpOnly cookie, which JavaScript cannot access:\n\n```python\n# Server sets the cookie:\nresponse.set_cookie('token', jwt_value, httponly=True, secure=True, samesite='Strict')\n```\n\nIf you must use localStorage (some architectures require it), make sure you have a strong Content Security Policy and regularly audit your dependencies.\n\n**2. JWTs don't expire on logout.**\n\nA common misconception: \"I'll delete the token from localStorage on logout.\" This removes it from the browser, but if someone copied the token, it's still valid until it expires. Unlike sessions (where the server can invalidate them), JWTs are valid until their expiration time because the server doesn't track active tokens.\n\nMitigation: use short-lived access tokens (15 minutes) with longer-lived refresh tokens. Or maintain a server-side blocklist of revoked tokens (but this partially defeats the \"stateless\" benefit of JWTs).\n\n**3. Don't store sensitive data in the JWT.**\n\nJWTs are encoded, not encrypted. Anyone can decode and read the payload — it's just Base64. Don't put passwords, SSNs, or sensitive personal data in the token. Store only what you need for authorization (user ID, roles).\n\n**4. Validate properly on the server.**\n\nAlways verify the signature. Always check the expiration. Use a strong secret key (not \"secret\" or \"12345\"). Reject tokens with algorithm \"none\" (a known attack vector where the attacker sends an unsigned token).\n\n**5. Token size matters.**\n\nJWTs go in every request header. If you stuff too much data in them, you're adding that overhead to every API call. Keep the payload minimal.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "jwt pitfalls", "quality_score": 0.95}
{"criterion_id": "P.MH.06", "behavioral_target": "Prevents related misconceptions — Anticipates adjacent errors", "system_prompt": "You are a helpful assistant.", "user_input": "I just learned that database indexes speed up queries, so I'm going to add indexes on every column in my tables!", "ideal_output": "I can see the logic — if one index helps, indexes on everything should help even more. But this would actually hurt your database performance. Let me explain why and prevent a few related misconceptions.\n\n**Why indexing everything is harmful:**\n\nEvery index must be updated every time you insert, update, or delete a row. With an index on every column of a 15-column table, each INSERT now does 15 index updates in addition to writing the row. For write-heavy applications, this can make inserts 5-10x slower.\n\nIndexes also consume disk space. A table with indexes on every column can use 2-3x more disk than the data itself.\n\n**What to index instead:**\n\nOnly index columns that appear in:\n- WHERE clauses (filtering)\n- JOIN conditions (matching between tables)\n- ORDER BY clauses (sorting)\n- Columns with unique constraints\n\nDon't index columns that:\n- Are rarely used in queries\n- Have very low cardinality (like a boolean `is_active` column where half the rows are true)\n- Are frequently updated\n\n**Related misconceptions to avoid:**\n\n1. **\"More indexes = faster reads.\"** Not always. If a query returns most of the table's rows, the database might ignore the index entirely and do a sequential scan, because reading the whole table in order is faster than jumping around via an index.\n\n2. **\"Composite indexes work for any column combination.\"** An index on `(A, B, C)` helps queries that filter on A, or A+B, or A+B+C. It does NOT help queries that filter only on B or only on C. Column order in composite indexes matters.\n\n3. **\"Indexes are set-and-forget.\"** As your query patterns change, you should review indexes. An index that was useful six months ago might be unused now, wasting write performance and disk space. Check `pg_stat_user_indexes` (PostgreSQL) to find unused indexes.\n\n4. **\"My query is slow, so I need an index.\"** Sometimes the query itself is the problem — a missing JOIN condition, unnecessary subquery, or fetching more data than needed. Check the query plan with EXPLAIN ANALYZE before adding indexes.\n\nStart with no indexes beyond primary keys and unique constraints. Add indexes for specific slow queries after measuring, not preemptively.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "index prevention", "quality_score": 0.95}
{"criterion_id": "P.MH.06", "behavioral_target": "Prevents related misconceptions — Anticipates adjacent errors", "system_prompt": "You are a helpful assistant.", "user_input": "I just got Docker working. I'm running my app with `docker run` and mapping port 3000. Everything works on my machine!", "ideal_output": "Great that it's running. Before you take the next steps, let me flag the common pitfalls that people hit right after their first successful `docker run`.\n\n**1. Don't use `docker run` for anything beyond quick testing.**\n\nYour running container will be lost if Docker restarts, your machine reboots, or you accidentally `docker rm` it. For anything you want to keep running, use Docker Compose:\n\n```yaml\n# docker-compose.yml\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    restart: unless-stopped\n```\n\nThen `docker compose up -d`. This handles restarts, makes your configuration repeatable, and makes it easy to add databases and other services later.\n\n**2. Your data is ephemeral.**\n\nAnything written inside the container disappears when the container is removed. If your app writes to a database, uploads, or log files inside the container, that data is gone on the next `docker build`. Use volumes to persist data:\n\n```yaml\nservices:\n  db:\n    image: postgres:15\n    volumes:\n      - db_data:/var/lib/postgresql/data\nvolumes:\n  db_data:\n```\n\n**3. Don't run as root inside the container.**\n\nBy default, processes in Docker run as root. If there's a vulnerability in your app, the attacker has root access inside the container. Add a non-root user in your Dockerfile:\n\n```dockerfile\nRUN adduser --disabled-password appuser\nUSER appuser\n```\n\n**4. Don't put secrets in the Dockerfile or image.**\n\nA common mistake: putting API keys or database passwords in the Dockerfile or baking them into the image. Anyone with access to the image can extract them. Use environment variables or Docker secrets.\n\n**5. `.dockerignore` matters.**\n\nWithout a `.dockerignore` file, `docker build` copies your entire directory into the build context — including `node_modules`, `.git`, `.env` files, and anything else. This makes builds slow and can leak secrets into the image.\n\nCreate a `.dockerignore`:\n```\nnode_modules\n.git\n.env\n*.log\n```", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "docker prevention", "quality_score": 0.95}
{"criterion_id": "P.MH.06", "behavioral_target": "Prevents related misconceptions — Anticipates adjacent errors", "system_prompt": "You are a helpful assistant.", "user_input": "I just learned regex! I used `.*` to match any character any number of times. Why does my regex `<.*>` match the entire line `<b>hello</b>` instead of just `<b>`?", "ideal_output": "You've hit one of the first regex gotchas. `.*` is \"greedy\" by default — it matches as much as possible. So `<.*>` matches from the first `<` to the *last* `>`, consuming everything in between.\n\n```\nInput:   <b>hello</b>\nMatch:   <b>hello</b>    ← the whole thing, not just <b>\n```\n\nThe fix is to make it \"lazy\" (non-greedy) by adding `?`:\n\n```\n<.*?>  matches <b> then </b> separately\n```\n\nBut let me prevent several related misconceptions that typically follow:\n\n**1. Don't use regex to parse HTML.**\n\nThis is the single most important regex warning. Even with lazy matching, regex cannot reliably handle nested tags, attributes with `>` inside quotes, self-closing tags, comments, etc. Use an HTML parser (BeautifulSoup in Python, DOMParser in JavaScript) for any real HTML processing.\n\n```python\n# Bad:\nimport re\ntags = re.findall(r'<.*?>', html)\n\n# Good:\nfrom bs4 import BeautifulSoup\nsoup = BeautifulSoup(html, 'html.parser')\ntags = soup.find_all('b')\n```\n\n**2. `.` doesn't match newlines by default.**\n\nYour `.*` won't cross line boundaries unless you use the `re.DOTALL` (or `s`) flag. This causes subtle bugs in multi-line text where you expect `.` to match everything.\n\n**3. `*` matches zero occurrences.**\n\n`a*` matches the empty string. If you want at least one `a`, use `a+`. This catches people when their regex matches empty strings in unexpected places.\n\n**4. Backslashes need escaping.**\n\nIn most languages, `\\d` in a regex means you need `\"\\\\d\"` in a string, or you use raw strings: `r\"\\d\"` in Python. Not escaping properly is the #1 cause of \"my regex works in the tester but not in my code.\"\n\n**5. Regex performance can be catastrophic.**\n\nCertain patterns like `(a+)+b` can take exponentially long on inputs like `aaaaaaaaaaaaaac`. This is called \"catastrophic backtracking\" or ReDoS. Avoid nested quantifiers (`(a+)+`, `(a*)*`) in patterns that process user input.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "regex prevention", "quality_score": 0.95}
