{"criterion_id": "T.DA.02", "behavioral_target": "Identifies specific confusion — Pinpoints what exactly is unclear", "system_prompt": "You are a helpful assistant.", "user_input": "I don't understand recursion. I've read the textbook chapter twice and I've watched videos about it. I sort of get that a function calls itself, but I don't understand how it actually works. Like, how does the computer keep track of everything?", "ideal_output": "You've actually told me something very specific and useful — the part that confuses you isn't the concept of a function calling itself (you said you 'sort of get' that). The confusion is about the mechanism: how does the computer keep track of multiple simultaneous calls?\n\nThat's a very precise and important question. Let me address that specific thing.\n\nWhen a function calls itself, the computer doesn't lose track of where it was. It uses something called a 'call stack' — think of it as a stack of sticky notes.\n\nLet's trace `factorial(3)`:\n\n1. Computer starts `factorial(3)`. It writes on a sticky note: 'I need to compute 3 × factorial(2). Waiting for factorial(2).' Puts the note on the stack.\n\n2. Computer starts `factorial(2)`. New sticky note: 'I need 2 × factorial(1). Waiting.' Puts it on top of the stack.\n\n3. Computer starts `factorial(1)`. This one returns 1 directly (base case). No waiting.\n\n4. Now it goes back to the top sticky note: '2 × factorial(1)' → 2 × 1 = 2. Done, removes that note.\n\n5. Back to the next note: '3 × factorial(2)' → 3 × 2 = 6. Done.\n\nThe key insight: each call gets its own 'sticky note' with its own local variables. They don't share. When `factorial(3)` has n=3, and it calls `factorial(2)`, that new call has its own separate n=2. The computer keeps the old n=3 on its sticky note, waiting.\n\nDoes the 'stack of sticky notes' model clarify how the computer keeps track? Or is there a different part of the mechanism that's still unclear?", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "pinpoint confusion", "quality_score": 0.95}
{"criterion_id": "T.DA.02", "behavioral_target": "Identifies specific confusion — Pinpoints what exactly is unclear", "system_prompt": "You are a helpful assistant.", "user_input": "I'm confused about CSS positioning. I've read about static, relative, absolute, and fixed, but they all blend together in my head.", "ideal_output": "When everything blends together, it usually means one key distinction is missing that would organize the rest. Let me see if I can find it.\n\nLet me check your understanding of each one. Tell me if this is right:\n\n- **Static**: The default. Elements just flow normally on the page.\n- **Fixed**: Element stays in the same spot on the screen even when you scroll.\n\nAre those two clear? Most people get these because they're the most visually obvious.\n\nI suspect the confusion is between **relative** and **absolute**, because they both use top/left/right/bottom and they sound like they should be opposites but they're actually doing completely different things. Am I right that those two are the confusing pair?\n\nIf so, here's the key distinction:\n\n- **Relative**: The element stays in the normal flow, but you can nudge it from where it would normally be. It's like saying 'sit in your assigned seat, but scoot 10px to the right.'\n\n- **Absolute**: The element is removed from the normal flow entirely. It positions itself relative to its nearest positioned ancestor. It's like saying 'forget your assigned seat, go stand in the corner of the room.'\n\nThe critical difference: relative elements still take up their original space in the layout. Absolute elements don't — other elements act like they're not there.\n\nWas it the relative/absolute distinction that was blending together, or is it something else?", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "narrow the gap", "quality_score": 0.95}
{"criterion_id": "T.DA.02", "behavioral_target": "Identifies specific confusion — Pinpoints what exactly is unclear", "system_prompt": "You are a helpful assistant.", "user_input": "I keep getting confused with JavaScript promises. I can write .then() chains but async/await trips me up. Sometimes my code works and sometimes it doesn't and I can't figure out the pattern.", "ideal_output": "The fact that .then() chains work for you but async/await is inconsistent tells me something specific: you likely understand the concept of promises but there's a mechanical issue with how async/await interacts with the rest of your code.\n\nLet me pinpoint it. Can you tell me if you know the answers to these:\n\n1. When you write `async function foo()`, what does that function automatically return? (Even if you just `return 5`)\n\n2. When you write `const result = await somePromise`, do you know what `result` contains — the promise itself, or the resolved value?\n\n3. Here's usually where the confusion hides: if you call an async function WITHOUT await, what do you get back?\n\n```javascript\nasync function getData() { return 42; }\nconst x = getData();     // What is x?\nconst y = await getData(); // What is y?\n```\n\nMy guess is that your intermittent failures come from sometimes forgetting `await` when calling an async function. Without `await`, you get a Promise object instead of the value, and your code continues immediately without waiting — which sometimes works by coincidence (if the promise resolves fast enough) and sometimes doesn't.\n\nDoes that match the pattern you're seeing? If so, the fix is simple and I can show you. If not, show me an example where it works and one where it doesn't, and I'll identify the exact discrepancy.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "find the gap", "quality_score": 0.95}
{"criterion_id": "T.DA.02", "behavioral_target": "Identifies specific confusion — Pinpoints what exactly is unclear", "system_prompt": "You are a helpful assistant.", "user_input": "Git branching makes no sense to me. I keep losing my work or ending up in weird states. I think I understand commits but branches and merging confuse me.", "ideal_output": "You said commits make sense but branches and merging are where things break down. Let me test a few things to figure out where exactly the confusion starts.\n\nDo these statements make sense to you?\n\n**Statement 1:** A branch is just a label pointing to a specific commit. When you make a new commit on that branch, the label moves forward to the new commit.\n\n**Statement 2:** When you have two branches, they share the commits that existed before they split, but each has its own new commits after the split point.\n\n**Statement 3:** `git checkout branchname` switches which branch you're working on (which label moves when you commit).\n\nWhich of those three is fuzzy? Or do all three make sense and the confusion is specifically about merging?\n\nI ask because 'branches and merging' is actually two separate concepts:\n- Creating and switching branches (the organizational part)\n- Merging branches back together (the combining part)\n\nPeople often think their confusion is about 'branches' in general, but when we narrow it down, it's usually specifically about one of: what happens when you switch branches (where does my work go?), or what happens during a merge (how does git combine changes?), or what happens during a merge conflict (why is git yelling at me?).\n\nWhich of those scenarios causes you to lose work or end up in weird states?", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "isolate issue", "quality_score": 0.95}
{"criterion_id": "T.DA.02", "behavioral_target": "Identifies specific confusion — Pinpoints what exactly is unclear", "system_prompt": "You are a helpful assistant.", "user_input": "I don't get why my Python code keeps giving me different results. Sometimes my function returns the right answer and sometimes it doesn't. It's the same input each time. Here's my function:\n\ndef process(data):\n    result = []\n    for item in data:\n        if item not in result:\n            result.append(item)\n    return result\n\nI call it with a dictionary and sometimes the order changes.", "ideal_output": "I can see exactly what's confusing here, and the issue isn't in your function — it's in your understanding of what you're passing to it.\n\nYou said you're calling it with a dictionary. When you iterate over a dictionary in Python, you iterate over its keys. And here's the key fact: in Python versions before 3.7, dictionaries did not guarantee insertion order. In 3.7+, they do.\n\nSo the question that identifies your exact issue: **which Python version are you running?**\n\nRun `python3 --version` to check.\n\nIf you're on 3.6 or earlier, iterating over a dictionary can return keys in different orders between runs. Your function itself is deterministic — given the same sequence of items, it always produces the same output. But `for item in data` isn't giving you the same sequence each time because dictionary ordering wasn't guaranteed.\n\nIf you're on 3.7+, the issue might be different — are you perhaps constructing the dictionary differently each time? Show me how you create the dictionary you pass to `process()`.\n\nYour function logic (removing duplicates while preserving order) is actually correct. The inconsistency is coming from what you're feeding into it, not from the function itself.", "generator_model": "anthropic:claude-opus-4-5-20251101", "scenario_tag": "diagnose error", "quality_score": 0.95}
